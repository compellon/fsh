{"version":3,"sources":["../../../src/lib/core/FSH.js"],"names":["fs","promisifyAll","require","handleHDFSError","err","response","has","data","url","res","statusCode","validateUri","pathOrUri","validProtocols","try","uri","isAbsolute","path","resolve","process","cwd","protocol","finalURIString","toString","test","replace","includes","FSH","constructor","user","host","port","conn","hostname","uriParts","omit","baseURI","client","create","defaults","baseURL","maxRedirects","validateStatus","status","_constructURL","op","params","queryParams","extend","clone","query","_sendRequest","method","opts","console","log","request","catch","mkdir","mode","self","then","ensureDirAsync","permissions","chmod","chmodAsync","chown","owner","group","chownAsync","readdir","readdirAsync","FileStatuses","FileStatus","copy","destination","all","spread","srcURI","destURI","copyAsync","copyToLocal","copyFromLocal","tmpDir","tmpdir","timestamp","Date","getTime","tmpFile","hdfsSrc","srcUri","destUri","hdfs","createClient","remoteFileStream","createReadStream","localFileStream","createWriteStream","reject","pipe","on","isError","hdfsDestination","rename","moveAsync","remove","unlink","recursive","unlinkAsync","removeAsync","stat","statAsync","writeJson","json","useHDFS","writeJsonAsync","writeFile","JSON","stringify","writeFileAsync","headers","location","appendFile","appendFileAsync","readFile","readFileAsync","readJson","readJsonAsync"],"mappings":"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","file":"FSH.js","sourcesContent":["import _ from 'lodash';\nimport Promise from 'bluebird';\nimport axios from 'axios';\nimport URI  from 'urijs';\nimport { HDFSError, ValidationError, ResponseError } from './errors';\nimport WebHDFS from 'webhdfs';\nimport os from 'os';\nimport path from 'path';\n\nconst fs = Promise.promisifyAll( require('fs-extra') );\n\nconst handleHDFSError = err => {\n    if ( err.response ) {\n        if ( _.has( err.response, 'data.RemoteException' ) )\n            throw new HDFSError( err.response.data );\n        else\n            throw new ResponseError( `Got unexpected status code for ${url}: ${res.statusCode}` );\n    }\n    throw err;\n};\n\nconst validateUri = ( pathOrUri, validProtocols = [ 'hdfs', 'file', '' ] ) => Promise.try( () => {\n    let uri = new URI( pathOrUri );\n\n    if ( !path.isAbsolute( uri.path() ) ) {\n        uri = new URI( path.resolve( process.cwd(), uri.path() ) );\n    }\n\n    if ( !uri.protocol() ) {\n        uri = uri.protocol('file');\n    }\n\n    let finalURIString = uri.toString();\n    if ( !/.*\\:\\/\\/.*/.test(finalURIString) ) {\n        finalURIString = finalURIString.replace(':', '://');\n    }\n\n    uri = URI( finalURIString );\n\n    if ( !_.includes( validProtocols, uri.protocol() ) )\n        throw new ValidationError( `Unsupported protocol [${uri.protocol()}].` );\n\n    return uri;\n});\n\nexport default class FSH {\n    constructor( { user = 'root', host = 'localhost', port = 50070, protocol = 'http', path = '/webhdfs/v1' } ) {\n        this.conn = { user, host, port, protocol, path, hostname: host };\n        const uriParts = _.omit( this.conn, [ 'user', 'host' ] );\n        this.baseURI = new URI( uriParts );\n        this.client = axios.create();\n        this.client.defaults.baseURL = this.baseURI.toString();\n        this.client.defaults.maxRedirects = 0;\n        this.client.defaults.validateStatus = status => status >= 200 && status < 400;\n    }\n\n    _constructURL( path, op, params = {} ) {\n        params['user.name'] = params['user.name'] || this.conn.user;\n        const queryParams = _.extend({ op }, params);\n        const uriParts = _.extend( _.clone( this.conn ), { path: this.conn.path + path } );\n        return new URI( uriParts ).query( queryParams );\n    }\n\n    _sendRequest( method, op, uri, params = {} ) {\n        const url = this._constructURL( uri.path(), op, params).toString();\n        const opts = { url, method };\n\n        if ( uri.hostname() )\n            opts.baseURL = new URI( this.baseURI ).hostname( uri.hostname() ).toString();\n\n        console.log('_sendRequest: returning this.client.request');\n        return this.client.request( opts ).catch( handleHDFSError );\n    }\n\n    mkdir( path, mode = 0o755 ) {\n        const self = this;\n        return validateUri( path ).then( uri => uri.protocol() !== 'hdfs' ?\n            fs.ensureDirAsync( uri.path(true), mode ) :\n            self._sendRequest( 'put', 'MKDIRS', uri, { permissions: mode } ).then( res => res.data )\n        );\n    }\n\n    chmod( path, mode = 0o755 ) {\n        const self = this;\n        return validateUri( path ).then( uri => uri.protocol() !== 'hdfs' ?\n            fs.chmodAsync( uri.path(true), mode ) :\n            self._sendRequest( 'put', 'SETPERMISSION', uri, { permissions: mode } ).then( res => res.data )\n        );\n    }\n\n    chown( path, owner, group ) {\n        const self = this;\n        return validateUri( path ).then( uri => uri.protocol() !== 'hdfs' ?\n            fs.chownAsync( uri.path(true), owner, group ) :\n            self._sendRequest( 'put', 'SETOWNER', uri, { owner, group } ).then( res => res.data )\n        );\n    }\n\n    readdir( path ) {\n        const self = this;\n        return validateUri( path ).then( uri => uri.protocol() !== 'hdfs' ?\n            fs.readdirAsync( uri.path(true), null ) :\n            self._sendRequest( 'get', 'LISTSTATUS', uri ).then( res => res.data.FileStatuses.FileStatus )\n        );\n    }\n\n    copy( path, destination ) {\n        const self = this;\n        return Promise.all([ validateUri( path ), validateUri( destination ) ])\n            .spread( ( srcURI, destURI ) => {\n                if ( srcURI.protocol() !== 'hdfs' && destURI.protocol() !== 'hdfs' )\n                    return fs.copyAsync( srcURI.path(true), destURI.path(true) );\n                else if ( srcURI.protocol() === 'hdfs' && destURI.protocol() !== 'hdfs' )\n                    return self.copyToLocal( path, destination );\n                else if ( srcURI.protocol() !== 'hdfs' && destURI.protocol() === 'hdfs' )\n                    return self.copyFromLocal( path, destination );\n                else if ( srcURI.protocol() === 'hdfs' && destURI.protocol() === 'hdfs' ) {\n                    const tmpDir = os.tmpdir();\n                    const timestamp = new Date().getTime();\n                    // TODO: replace with guids?\n                    const tmpFile = `${tmpDir}/${timestamp}`;\n\n                    return self.copyToLocal( path, tmpFile ).then( () => self.copyFromLocal( tmpFile, destination) );\n                }\n            });\n    }\n\n    // TODO: implement without webhdfs lib\n    copyToLocal( hdfsSrc, destination ) {\n        return Promise.all([ validateUri( hdfsSrc, [ 'hdfs' ] ), validateUri( destination, [ 'file', '' ] ) ] )\n            .spread( ( srcUri, destUri ) => {\n                const conn = _.omit( this.conn, 'hostname' );\n                if ( srcUri.hostname() ) conn.host = srcUri.hostname();\n                const hdfs = WebHDFS.createClient( conn );\n\n                const remoteFileStream = hdfs.createReadStream( srcUri.path(true) );\n                const localFileStream = fs.createWriteStream( destUri.path(true) );\n\n                return new Promise( ( resolve, reject ) => {\n                    remoteFileStream.pipe( localFileStream );\n\n                    localFileStream.on( 'error', reject );\n\n                    localFileStream.on( 'finish', res => {\n                        if ( _.isError( res ) ) {\n                            return reject(res);\n                        }\n                        resolve();\n                    });\n                });\n            });\n    }\n\n    // TODO: implement without webhdfs lib\n    copyFromLocal( path, hdfsDestination ) {\n        const self = this;\n        return Promise.all([ validateUri( path, ['file', ''] ), validateUri( hdfsDestination, [ 'hdfs' ] ) ])\n            .spread( ( srcUri, destUri ) => {\n                const conn = _.omit( this.conn, 'hostname' );\n                if ( srcUri.hostname() ) conn.host = srcUri.hostname();\n                const hdfs = WebHDFS.createClient( conn );\n\n                const localFileStream = fs.createReadStream( srcUri.path(true) );\n                const remoteFileStream = hdfs.createWriteStream( destUri.path(true) );\n\n                return new Promise( ( resolve, reject ) => {\n                    localFileStream.pipe( remoteFileStream );\n\n                    remoteFileStream.on( 'error', reject );\n\n                    remoteFileStream.on( 'finish', res => {\n                        if ( _.isError( res ) ) {\n                            return reject( res );\n                        }\n                        resolve();\n                    });\n                });\n            });\n    }\n\n    rename( path, destination ) {\n        const self = this;\n        return Promise.all([ validateUri( path ), validateUri( destination ) ])\n            .spread( ( srcUri, destURI ) => {\n                if ( srcUri.protocol() !== 'hdfs' && destURI.protocol() !== 'hdfs' ) {\n                    return fs.moveAsync( srcUri.path(true), destURI.path(true) );\n                } else {\n                    return self.copy( path, destination ).then( () => self.remove( path ) );\n                }\n            });\n    }\n\n    unlink( path, recursive = null) {\n        const self = this;\n        return validateUri( path ).then( uri => uri.protocol() !== 'hdfs' ?\n            fs.unlinkAsync( uri.path(true) ) :\n            self._sendRequest( 'delete', 'DELETE', uri, { recursive } ).then( res => res.data )\n        );\n    }\n\n    remove( path ) {\n        const self = this;\n        return validateUri( path ).then( uri => uri.protocol() !== 'hdfs' ?\n            fs.removeAsync( uri.path(true) ) :\n            self.unlink( path, true )\n        );\n    }\n\n    stat( path ) {\n        const self = this;\n        return validateUri( path ).then( uri => uri.protocol() !== 'hdfs' ?\n            fs.statAsync( uri.path(true) ) :\n            self._sendRequest( 'get', 'GETFILESTATUS', uri ).then( res => res.data.FileStatus )\n        );\n    }\n\n    writeJson( path, json, opts = {} ) {\n        const self = this;\n        console.log('writeJson: validating URI');\n        return validateUri( path ).then( uri => {\n            const useHDFS = uri.protocol() === 'hdfs';\n\n            if (typeof json !== 'object')\n                throw new ValidationError('Input must be an object. Try using writeFile instead or convert to an object.');\n\n            if ( !useHDFS ) return fs.writeJsonAsync( uri.path(true), json, opts );\n            console.log('writeJson: calling self.writeFile');\n            return self.writeFile( path, JSON.stringify( json ), opts );\n        });\n    }\n\n    writeFile( path, data, opts = {} ) {\n        const self = this;\n        console.log('writeFile: calling validateUri then self._sendRequest');\n        return validateUri( path )\n            .then( uri => uri.protocol() !== 'hdfs' ? fs.writeFileAsync( uri.path(true), data, opts ) : self._sendRequest( 'put', 'CREATE', uri, opts )\n            .then( res => res.headers.location )\n            .then( url => {\n                console.log('writeFile: sending axios.request to the location received from _sendRequest');\n                return axios.request( { url, method: 'put', data } );\n            } )\n            .then( res => {\n                console.log('writeFile: operation complete, returning data.');\n                return res.data;\n            } )\n            .catch( err => handleHDFSError )\n        );\n    }\n\n    appendFile( path, data, opts = {} ) {\n        const self = this;\n        return validateUri( path ).then( uri => uri.protocol() !== 'hdfs' ?\n            fs.appendFileAsync( uri.path(true), data, opts ) :\n            self._sendRequest( 'post', 'APPEND', uri, opts )\n                .then( res => res.headers.location )\n                .then( url => axios.request( { url, method: 'post', data } ) )\n                .then( res => res.data )\n                .catch( err => handleHDFSError )\n        );\n    }\n\n    readFile( path, opts = {} ) {\n        const self = this;\n        return validateUri( path ).then( uri => uri.protocol() !== 'hdfs' ?\n            fs.readFileAsync( uri.path(true), opts ) :\n            self._sendRequest( 'get', 'OPEN', uri, opts )\n                .then( res => res.headers.location )\n                .then( url => axios.request( { url, method: 'get' } ) )\n                .then( res => res.data )\n                .catch( err => handleHDFSError )\n        );\n    }\n\n    readJson( path, opts = {} ) {\n        const self = this;\n        return validateUri( path ).then( uri => uri.protocol() !== 'hdfs' ?\n            fs.readJsonAsync( uri.path(true), opts ) :\n            this.readFile( path, opts).then( JSON.stringify )\n        );\n    }\n}\n"]}